#version 100

struct modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
};

uniform modelWideBlockPS _65;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture2D(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture2D(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 fogColor = _65.FogColor.xyz;
    float fog_start = _65.uSunDir_FogStart.w;
    float fog_end = _65.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform modelWideBlockVS _55;

attribute float aIndex;
attribute float aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    bool _20 = stepX > 0.100000001490116119384765625;
    if (_20)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
    mat4 animationMat[4];
};

uniform meshWideBlockPS _387;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _621;

struct modelWideBlockPS
{
    vec4 uFogStartAndFogEnd;
    vec4 uFogColor;
};

uniform modelWideBlockPS _741;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

varying vec2 vChunkCoords;
varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vVertexLighting;
varying vec3 vPosition;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _42 = !applyLight;
    if (_42)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _59 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_59)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _97 = nDotUp >= 0.0;
        if (_97)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _137 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_137)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _161 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_161)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _334 = nDotSun > 0.0;
    if (_334)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture2D(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = (_387.animationMat[0] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer1 = (_387.animationMat[1] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer2 = (_387.animationMat[2] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer3 = (_387.animationMat[3] * vec4(vTexCoord, 0.0, 1.0)).xy;
    float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
    vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
    float weightedTexture_x = minusAlphaBlendSum * ((texture2D(uLayerHeight0, tcLayer0).w * _387.uHeightScale.x) + _387.uHeightOffset.x);
    float weightedTexture_y = weightsVector.y * ((texture2D(uLayerHeight1, tcLayer1).w * _387.uHeightScale.y) + _387.uHeightOffset.y);
    float weightedTexture_z = weightsVector.z * ((texture2D(uLayerHeight2, tcLayer2).w * _387.uHeightScale.z) + _387.uHeightOffset.z);
    float weightedTexture_w = weightsVector.w * ((texture2D(uLayerHeight3, tcLayer3).w * _387.uHeightScale.w) + _387.uHeightOffset.w);
    vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
    vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
    vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
    vec4 weightedLayer_0 = texture2D(uLayer0, tcLayer0) * weightsNormalized.x;
    vec3 matDiffuse_0 = weightedLayer_0.xyz;
    float specBlend_0 = weightedLayer_0.w;
    vec4 weightedLayer_1 = texture2D(uLayer1, tcLayer1) * weightsNormalized.y;
    vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
    float specBlend_1 = specBlend_0 + weightedLayer_1.w;
    vec4 weightedLayer_2 = texture2D(uLayer2, tcLayer1) * weightsNormalized.z;
    vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
    float specBlend_2 = specBlend_1 + weightedLayer_2.w;
    vec4 weightedLayer_3 = texture2D(uLayer3, tcLayer1) * weightsNormalized.w;
    vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
    float specBlend_3 = specBlend_2 + weightedLayer_3.w;
    vec4 final = vec4(matDiffuse_3, specBlend_3);
    vec3 matDiffuse = (final.xyz * 2.0) * vColor.xyz;
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = 0.0;
    SceneWideParams param_4;
    param_4.uLookAtMat = _621.scene.uLookAtMat;
    param_4.uPMatrix = _621.scene.uPMatrix;
    param_4.uViewUp = _621.scene.uViewUp;
    param_4.uInteriorSunDir = _621.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _621.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _621.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _621.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _621.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _621.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_6 = vVertexLighting;
    vec4 finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), vec3(0.0)), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_621.scene.extLight.uExteriorDirectColorDir.xyz + normalize(vPosition));
    vec3 lSpecular = _621.scene.extLight.uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _699 = finalColor.xyz + specTerm;
    finalColor = vec4(_699.x, _699.y, _699.z, finalColor.w);
    PSFog arg;
    arg.densityParams = _621.fogData.densityParams;
    arg.heightPlane = _621.fogData.heightPlane;
    arg.color_and_heightRate = _621.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _621.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _621.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _621.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _621.fogData.sunPercentage;
    vec3 param_7 = finalColor.xyz;
    vec3 param_8 = vPosition;
    vec3 param_9 = _621.scene.extLight.uExteriorDirectColorDir.xyz;
    vec3 _732 = makeFog(arg, param_7, param_8, param_9);
    finalColor = vec4(_732.x, _732.y, _732.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _91;

struct meshWideBlockVS
{
    vec4 uPos;
};

uniform meshWideBlockVS _131;

attribute float aIndex;
attribute vec3 aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec3 vVertexLighting;
attribute vec4 aVertexLighting;
varying vec3 vNormal;
attribute vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    bool _61 = iX > 8.0100002288818359375;
    if (_61)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_91.scene.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _91.scene.uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_91.scene.uPMatrix * _91.scene.uLookAtMat) * worldPoint;
}


#version 100

struct meshWideBlockPS
{
    vec4 color;
};

uniform meshWideBlockPS _12;

uniform sampler2D uTexture;

varying vec2 vTextCoords;
varying vec3 vPosition;

void main()
{
    gl_FragData[0] = vec4(_12.color.xyz * texture2D(uTexture, vTextCoords).xyz, 0.699999988079071044921875);
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _27;

attribute vec4 aPositionTransp;
varying vec2 vTextCoords;
varying vec3 vPosition;
attribute vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _27.scene.uLookAtMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy / vec2(33.333332061767578125);
    gl_Position = _27.scene.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _13;

void main()
{
    vec4 finalColor = _13.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _21;

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _59;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 100

struct meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
};

uniform meshWideBlockPS _10;

uniform sampler2D diffuse;

varying vec2 texCoord;

void main()
{
    bool _17 = _10.drawDepth == 1;
    vec4 finalColor;
    if (_17)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture2D(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture2D(diffuse, texCoord).xyz, 255.0);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    vec3 uColor;
};

uniform meshWideBlockPS _22;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _13;

attribute vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 100

struct modelWideBlockPS
{
    vec3 uColor;
};

uniform modelWideBlockPS _19;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

attribute vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 100

struct modelWideBlockVS
{
    vec3 uColor;
};

uniform modelWideBlockVS _13;

varying vec4 vPos;

void main()
{
    gl_FragData[0] = vec4(_13.uColor, 1.0);
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _29;

attribute vec3 aPosition;
varying vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 100

struct modelWideBlockVS
{
    vec4 uColor;
};

uniform modelWideBlockVS _12;

void main()
{
    vec4 finalColor = _12.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _30;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _40;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 100

struct meshWideBlockVS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
};

uniform meshWideBlockVS _36;

varying vec2 texCoord;
attribute vec2 position;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.5, 1.0);
}


#version 100

struct meshWideBlockPS
{
    vec4 texOffsetX;
    vec4 texOffsetY;
};

uniform meshWideBlockPS _33;

uniform sampler2D texture0;

varying vec2 texCoord;

void main()
{
    vec2 tex_offset = vec2(0.001000000047497451305389404296875);
    vec3 result = texture2D(texture0, texCoord).xyz * 0.0;
    result = vec3(0.0);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.x * tex_offset.x, _33.texOffsetY.x * tex_offset.y)).xyz * 0.125);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.y * tex_offset.x, _33.texOffsetY.y * tex_offset.y)).xyz * 0.375);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.z * tex_offset.x, _33.texOffsetY.z * tex_offset.y)).xyz * 0.375);
    result += (texture2D(texture0, texCoord + vec2(_33.texOffsetX.w * tex_offset.x, _33.texOffsetY.w * tex_offset.y)).xyz * 0.125);
    gl_FragData[0] = vec4(result, 1.0);
}


#version 100

struct meshWideBlockPS
{
    vec4 blurAmount;
};

uniform meshWideBlockPS _34;

uniform sampler2D screenTex;
uniform sampler2D blurTex;

varying vec2 texCoord;

void main()
{
    vec4 screen = texture2D(screenTex, texCoord);
    vec3 blurred = texture2D(blurTex, texCoord).xyz;
    vec3 mixed = mix(screen.xyz, blurred, vec3(_34.blurAmount.z));
    vec3 glow = (blurred * blurred) * _34.blurAmount.w;
    gl_FragData[0] = vec4(mixed + glow, screen.w);
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D Texture;

varying vec4 Frag_Color;
varying vec2 Frag_UV;

void main()
{
    gl_FragData[0] = Frag_Color * texture2D(Texture, Frag_UV);
}


#version 100

struct modelWideBlockVS
{
    mat4 ProjMtx;
};

uniform modelWideBlockVS _30;

varying vec2 Frag_UV;
attribute vec2 UV;
varying vec4 Frag_Color;
attribute vec4 Color;
attribute vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30.ProjMtx * vec4(Position, 0.0, 1.0);
}


#version 100

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
};

uniform meshWideBlockPS _212;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _378;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexcoord0;
varying vec2 vTexcoord1;
varying vec2 vTexcoord2;
varying vec4 vColor;
varying vec3 vPosition;

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _162 = nDotSun > 0.0;
    if (_162)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    vec4 tex2 = texture2D(uTexture2, vTexcoord1);
    vec4 tex3 = texture2D(uTexture3, vTexcoord2);
    float uAlphaTest = _212.uAlphaTestv.x;
    bool _219 = tex.w < uAlphaTest;
    if (_219)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _212.uPixelShaderv.x;
    bool _246 = uNonOptPixelShader == 0;
    if (_246)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        bool _267 = uNonOptPixelShader == 1;
        if (_267)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            bool _299 = uNonOptPixelShader == 2;
            if (_299)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                bool _330 = uNonOptPixelShader == 3;
                if (_330)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    bool _361 = uNonOptPixelShader == 4;
                    if (_361)
                    {
                    }
                }
            }
        }
    }
    bool _367 = finalColor.w < uAlphaTest;
    if (_367)
    {
        discard;
    }
    vec3 sunDir = _378.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _378.fogData.densityParams;
    arg.heightPlane = _378.fogData.heightPlane;
    arg.color_and_heightRate = _378.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _378.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _378.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _378.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _378.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    vec3 _413 = makeFog(arg, param, param_1, param_2);
    finalColor = vec4(_413.x, _413.y, _413.z, finalColor.w);
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _43;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec2 vTexcoord1;
attribute vec2 aTexcoord1;
varying vec2 vTexcoord2;
attribute vec2 aTexcoord2;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    vec4 vertexViewSpace = _43.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _43.scene.uPMatrix * vertexViewSpace;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

struct meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight;
    vec4 uFogColorAndAlphaTest;
    vec4 uPcColor;
};

uniform meshWideBlockPS _409;

struct modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCountAndBcHack;
    vec4 interiorExteriorBlend;
};

uniform modelWideBlockPS _433;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _472;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _480;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec3 vPosition;
varying vec3 vNormal;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _42 = !applyLight;
    if (_42)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _59 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_59)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _97 = nDotUp >= 0.0;
        if (_97)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _137 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_137)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _161 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_161)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _334 = nDotSun > 0.0;
    if (_334)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture2D(uTexture, texCoord);
    vec4 tex2 = texture2D(uTexture2, texCoord2);
    vec4 tex3 = texture2D(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture2D(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture2D(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture2D(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    bool _413 = _409.PixelShader_UnFogged_IsAffectedByLight.z == 1;
    vec3 accumLight;
    if (_413)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_433.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _449 = index >= _433.lightCountAndBcHack.x;
            if (_449)
            {
                break;
            }
            lightRecord.color = _433.pc_lights[index].color;
            lightRecord.position = _433.pc_lights[index].position;
            lightRecord.attenuation = _433.pc_lights[index].attenuation;
            vec3 vectorToLight = (_472.scene.uLookAtMat * (_480.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _547 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_547.x, _547.y, _547.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_433.lightCountAndBcHack.y)));
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _409.PixelShader_UnFogged_IsAffectedByLight.x;
    bool _574 = uPixelShader == 0;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _595 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _615 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _643 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _668 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _689 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _709 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _736 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _765 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _791 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _816 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _839 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _863 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _891 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _914 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _941 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * genericParams[0].z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _977 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1003 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1051 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1081 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1109 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1135 = uPixelShader == 21;
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1165 = uPixelShader == 22;
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1192 = uPixelShader == 23;
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1221 = uPixelShader == 24;
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * genericParams[0].x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1253 = uPixelShader == 25;
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * genericParams[0].z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1295 = uPixelShader == 26;
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1340 = uPixelShader == 27;
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1374 = uPixelShader == 28;
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1422 = uPixelShader == 29;
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1446 = uPixelShader == 30;
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1491 = uPixelShader == 31;
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1526 = uPixelShader == 32;
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1568 = uPixelShader == 33;
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1592 = uPixelShader == 34;
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    bool _1598 = uPixelShader == 35;
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    opacity = (((tex * tex2) * tex3) * genericParams[0]).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1633 = uPixelShader == 36;
    #if (FRAGMENTSHADER == 36)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _409.PixelShader_UnFogged_IsAffectedByLight.z > 0;
    float param_3 = _433.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _472.scene.uLookAtMat;
    param_4.uPMatrix = _472.scene.uPMatrix;
    param_4.uViewUp = _472.scene.uViewUp;
    param_4.uInteriorSunDir = _472.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _472.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _472.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _472.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _472.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _472.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _433.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _433.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular), finalOpacity);
    bool _1715 = finalColor.w < _409.uFogColorAndAlphaTest.w;
    if (_1715)
    {
        discard;
    }
    int uUnFogged = _409.PixelShader_UnFogged_IsAffectedByLight.y;
    bool _1723 = uUnFogged == 0;
    if (_1723)
    {
        vec3 sunDir = mix(_472.scene.uInteriorSunDir, _472.scene.extLight.uExteriorDirectColorDir, vec4(_433.interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _472.fogData.densityParams;
        arg.heightPlane = _472.fogData.heightPlane;
        arg.color_and_heightRate = _472.fogData.color_and_heightRate;
        arg.heightDensity_and_endColor = _472.fogData.heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _472.fogData.sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _472.fogData.heightColor_and_endFogDistance;
        arg.sunPercentage = _472.fogData.sunPercentage;
        vec3 param_7 = finalColor.xyz;
        vec3 param_8 = vPosition;
        vec3 param_9 = sunDir;
        vec3 _1765 = makeFog(arg, param_7, param_8, param_9);
        finalColor = vec4(_1765.x, _1765.y, _1765.z, finalColor.w);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _133;

struct meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
};

uniform meshWideBlockVS _230;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _240;

attribute vec3 aPosition;
attribute vec4 boneWeights;
attribute vec4 bones;
attribute vec3 aNormal;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
attribute vec2 aTexCoord2;
varying vec3 vNormal;
varying vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_240.scene.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _240.scene.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    bool _305 = uVertexShader == 0;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _332 = uVertexShader == 1;
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    bool _347 = uVertexShader == 2;
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _379 = uVertexShader == 3;
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    bool _403 = uVertexShader == 4;
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _427 = uVertexShader == 5;
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    bool _444 = uVertexShader == 6;
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _476 = uVertexShader == 7;
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _507 = uVertexShader == 8;
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _546 = uVertexShader == 9;
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _571 = uVertexShader == 10;
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _594 = uVertexShader == 11;
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _626 = uVertexShader == 12;
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _659 = uVertexShader == 13;
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    bool _677 = uVertexShader == 14;
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _716 = uVertexShader == 15;
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    bool _748 = uVertexShader == 16;
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    bool _780 = uVertexShader == 17;
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _803 = uVertexShader == 18;
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _240.scene.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 100

struct meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
};

uniform meshWideBlockPS _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

varying vec2 v_texcoord;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture2D(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture2D(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture2D(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture2D(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture2D(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture2D(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture2D(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    bool _240 = (lumaB < lumaMin) || (lumaB > lumaMax);
    if (_240)
    {
        gl_FragData[0] = vec4(rgbA.x, rgbA.y, rgbA.z, gl_FragData[0].w);
    }
    else
    {
        gl_FragData[0] = vec4(rgbB.x, rgbB.y, rgbB.z, gl_FragData[0].w);
    }
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

attribute vec4 a_position;
varying vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 100

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _221;

uniform sampler2D uTexture;

varying vec2 vTexcoord0;
varying vec4 vColor;
varying vec3 vPosition;

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _162 = nDotSun > 0.0;
    if (_162)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    vec4 finalColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
    vec3 sunDir = _221.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _221.fogData.densityParams;
    arg.heightPlane = _221.fogData.heightPlane;
    arg.color_and_heightRate = _221.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _221.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _221.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _221.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _221.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    vec3 _256 = makeFog(arg, param, param_1, param_2);
    finalColor = vec4(_256.x, _256.y, _256.z, finalColor.w);
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _37;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vec4 vertexViewSpace = _37.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _37.scene.uPMatrix * vertexViewSpace;
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

varying vec4 vColor;

void main()
{
    gl_FragData[0] = vec4(vColor.xyz, 1.0);
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _50;

struct meshWideBlockVS
{
    vec4 skyColor[6];
};

uniform meshWideBlockVS _82;

attribute vec4 aPosition;
varying vec4 vColor;

void main()
{
    vec3 inputPos = aPosition.xyz;
    vec2 _20 = inputPos.xy / vec2(0.6875);
    inputPos = vec3(_20.x, _20.y, inputPos.z);
    bool _30 = inputPos.z > 0.0;
    float _31;
    if (_30)
    {
        _31 = inputPos.z / 0.292800009250640869140625;
    }
    else
    {
        _31 = inputPos.z;
    }
    inputPos.z = _31;
    vec4 cameraPos = _50.scene.uLookAtMat * vec4(inputPos, 1.0);
    vec3 _70 = cameraPos.xyz - _50.scene.uLookAtMat[3].xyz;
    cameraPos = vec4(_70.x, _70.y, _70.z, cameraPos.w);
    cameraPos.z = cameraPos.z;
    vColor = vec4(_82.skyColor[int(aPosition.w)].xyz, 1.0);
    gl_Position = _50.scene.uPMatrix * cameraPos;
}


#version 100

struct meshWideBlockPS
{
    ivec4 waterTypeV;
};

uniform meshWideBlockPS _12;

uniform sampler2D uTexture;

varying vec3 vPosition;

void main()
{
    int waterType = _12.waterTypeV.x;
    bool _22 = waterType == 13;
    if (_22)
    {
        gl_FragData[0] = vec4(0.0, 0.0, 0.300000011920928955078125, 0.5);
    }
    else
    {
        bool _36 = waterType == 14;
        if (_36)
        {
            gl_FragData[0] = vec4(0.0, 0.0, 0.800000011920928955078125, 0.800000011920928955078125);
        }
        else
        {
            bool _44 = waterType == 19;
            if (_44)
            {
                gl_FragData[0] = vec4(0.300000011920928955078125, 0.0, 0.0, 0.5);
            }
            else
            {
                bool _51 = waterType == 20;
                if (_51)
                {
                    gl_FragData[0] = vec4(0.0, 0.5, 0.0, 0.5);
                }
                else
                {
                    gl_FragData[0] = vec4(0.5);
                }
            }
        }
    }
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _24;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _32;

attribute vec3 aPosition;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 cameraMatrix = _24.uLookAtMat * _32.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    gl_Position = _24.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct meshWideBlockPS
{
    ivec4 UseLitColor_EnableAlpha_PixelShader;
    vec4 FogColor_AlphaTest;
};

uniform meshWideBlockPS _383;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _848;

struct modelWideBlockPS
{
    InteriorLightParam intLight;
};

uniform modelWideBlockPS _852;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vColor;
varying vec4 vColor2;
varying vec3 vNormal;
varying vec4 vPosition;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _42 = !applyLight;
    if (_42)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _59 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_59)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _97 = nDotUp >= 0.0;
        if (_97)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _137 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_137)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _161 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_161)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _334 = nDotSun > 0.0;
    if (_334)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexCoord);
    vec4 tex2 = texture2D(uTexture2, vTexCoord2);
    vec4 tex3 = texture2D(uTexture3, vTexCoord3);
    bool _387 = _383.UseLitColor_EnableAlpha_PixelShader.y == 1;
    if (_387)
    {
        bool _394 = (tex.w - 0.501960813999176025390625) < 0.0;
        if (_394)
        {
            discard;
        }
    }
    int uPixelShader = _383.UseLitColor_EnableAlpha_PixelShader.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 matDiffuse = vec3(0.0);
    vec3 env = vec3(0.0);
    float finalOpacity = 0.0;
    bool _409 = uPixelShader == (-1);
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalOpacity = tex.w;
    #endif
    bool _430 = uPixelShader == 0;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _445 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _458 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _471 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = tex2.xyz * tex.w;
    finalOpacity = vColor.w;
    #endif
    bool _489 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _502 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex.xyz * tex.w) * tex2.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _523 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _552 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz * (vColor.xyz * 2.0);
    env = (colorMix.xyz * colorMix.w) * tex3.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _581 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _605 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = vColor.w;
    #endif
    bool _627 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = vColor.w;
    #endif
    bool _663 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _694 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _714 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    env = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _748 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _762 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _776 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _789 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _802 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _815 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _828 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = vPosition.w;
    SceneWideParams param_4;
    param_4.uLookAtMat = _848.scene.uLookAtMat;
    param_4.uPMatrix = _848.scene.uPMatrix;
    param_4.uViewUp = _848.scene.uViewUp;
    param_4.uInteriorSunDir = _848.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _848.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _848.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _848.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _848.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _848.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _852.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _852.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = vec3(0.0);
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vColor2.xyz, vec3(0.0)), finalOpacity);
    bool _909 = finalColor.w < _383.FogColor_AlphaTest.w;
    if (_909)
    {
        discard;
    }
    PSFog arg;
    arg.densityParams = _848.fogData.densityParams;
    arg.heightPlane = _848.fogData.heightPlane;
    arg.color_and_heightRate = _848.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _848.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _848.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _848.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _848.fogData.sunPercentage;
    vec3 param_7 = finalColor.xyz;
    vec3 param_8 = vPosition.xyz;
    vec3 param_9 = _848.scene.extLight.uExteriorDirectColorDir.xyz;
    vec3 _945 = makeFog(arg, param_7, param_8, param_9);
    finalColor = vec4(_945.x, _945.y, _945.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _93;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
};

uniform sceneWideBlockVSPS _111;

struct meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
};

uniform meshWideBlockVS _182;

attribute vec3 aPosition;
varying vec4 vPosition;
attribute vec4 aColor;
varying vec3 vNormal;
attribute vec3 aNormal;
varying vec4 vColor;
varying vec4 vColor2;
attribute vec4 aColor2;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
varying vec2 vTexCoord2;
attribute vec2 aTexCoord2;
varying vec2 vTexCoord3;
attribute vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _111.scene.uLookAtMat * worldPoint;
    mat4 viewModelMat = _111.scene.uLookAtMat * _93.uPlacementMat;
    mat4 param = _111.scene.uLookAtMat;
    mat4 param_1 = _93.uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _111.scene.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _182.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vTexCoord2 = posToTexCoord(param_2, param_3);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
} _65;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

in vec2 vChunkCoords;
in vec3 vPosition;
layout(location = 0) out vec4 fragColor;

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 fogColor = _65.FogColor.xyz;
    float fog_start = _65.uSunDir_FogStart.w;
    float fog_end = _65.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _55;

layout(location = 1) in float aIndex;
layout(location = 0) in float aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    bool _20 = stepX > 0.100000001490116119384765625;
    if (_20)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
    mat4 animationMat[4];
} _387;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _621;

layout(std140) uniform modelWideBlockPS
{
    vec4 uFogStartAndFogEnd;
    vec4 uFogColor;
} _741;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

in vec2 vChunkCoords;
in vec4 vColor;
in vec3 vNormal;
in vec3 vVertexLighting;
in vec3 vPosition;
layout(location = 0) out vec4 outColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _42 = !applyLight;
    if (_42)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _59 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_59)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _97 = nDotUp >= 0.0;
        if (_97)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _137 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_137)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _161 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_161)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _334 = nDotSun > 0.0;
    if (_334)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = (_387.animationMat[0] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer1 = (_387.animationMat[1] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer2 = (_387.animationMat[2] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer3 = (_387.animationMat[3] * vec4(vTexCoord, 0.0, 1.0)).xy;
    float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
    vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
    float weightedTexture_x = minusAlphaBlendSum * ((texture(uLayerHeight0, tcLayer0).w * _387.uHeightScale.x) + _387.uHeightOffset.x);
    float weightedTexture_y = weightsVector.y * ((texture(uLayerHeight1, tcLayer1).w * _387.uHeightScale.y) + _387.uHeightOffset.y);
    float weightedTexture_z = weightsVector.z * ((texture(uLayerHeight2, tcLayer2).w * _387.uHeightScale.z) + _387.uHeightOffset.z);
    float weightedTexture_w = weightsVector.w * ((texture(uLayerHeight3, tcLayer3).w * _387.uHeightScale.w) + _387.uHeightOffset.w);
    vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
    vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
    vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
    vec4 weightedLayer_0 = texture(uLayer0, tcLayer0) * weightsNormalized.x;
    vec3 matDiffuse_0 = weightedLayer_0.xyz;
    float specBlend_0 = weightedLayer_0.w;
    vec4 weightedLayer_1 = texture(uLayer1, tcLayer1) * weightsNormalized.y;
    vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
    float specBlend_1 = specBlend_0 + weightedLayer_1.w;
    vec4 weightedLayer_2 = texture(uLayer2, tcLayer1) * weightsNormalized.z;
    vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
    float specBlend_2 = specBlend_1 + weightedLayer_2.w;
    vec4 weightedLayer_3 = texture(uLayer3, tcLayer1) * weightsNormalized.w;
    vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
    float specBlend_3 = specBlend_2 + weightedLayer_3.w;
    vec4 final = vec4(matDiffuse_3, specBlend_3);
    vec3 matDiffuse = (final.xyz * 2.0) * vColor.xyz;
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = 0.0;
    SceneWideParams param_4;
    param_4.uLookAtMat = _621.scene.uLookAtMat;
    param_4.uPMatrix = _621.scene.uPMatrix;
    param_4.uViewUp = _621.scene.uViewUp;
    param_4.uInteriorSunDir = _621.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _621.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _621.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _621.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _621.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _621.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_6 = vVertexLighting;
    vec4 finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), vec3(0.0)), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_621.scene.extLight.uExteriorDirectColorDir.xyz + normalize(vPosition));
    vec3 lSpecular = _621.scene.extLight.uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _699 = finalColor.xyz + specTerm;
    finalColor = vec4(_699.x, _699.y, _699.z, finalColor.w);
    PSFog arg;
    arg.densityParams = _621.fogData.densityParams;
    arg.heightPlane = _621.fogData.heightPlane;
    arg.color_and_heightRate = _621.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _621.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _621.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _621.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _621.fogData.sunPercentage;
    vec3 param_7 = finalColor.xyz;
    vec3 param_8 = vPosition;
    vec3 param_9 = _621.scene.extLight.uExteriorDirectColorDir.xyz;
    vec3 _732 = makeFog(arg, param_7, param_8, param_9);
    finalColor = vec4(_732.x, _732.y, _732.z, finalColor.w);
    finalColor.w = 1.0;
    outColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _91;

layout(std140) uniform meshWideBlockVS
{
    vec4 uPos;
} _131;

layout(location = 4) in float aIndex;
layout(location = 0) in vec3 aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec3 vVertexLighting;
layout(location = 2) in vec4 aVertexLighting;
out vec3 vNormal;
layout(location = 3) in vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    bool _61 = iX > 8.0100002288818359375;
    if (_61)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_91.scene.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _91.scene.uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_91.scene.uPMatrix * _91.scene.uLookAtMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 color;
} _12;

uniform sampler2D uTexture;

layout(location = 0) out vec4 outputColor;
in vec2 vTextCoords;
in vec3 vPosition;

void main()
{
    outputColor = vec4(_12.color.xyz * texture(uTexture, vTextCoords).xyz, 0.699999988079071044921875);
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _27;

layout(location = 0) in vec4 aPositionTransp;
out vec2 vTextCoords;
out vec3 vPosition;
layout(location = 1) in vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _27.scene.uLookAtMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy / vec2(33.333332061767578125);
    gl_Position = _27.scene.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _13;

layout(location = 0) out vec4 outColor;

void main()
{
    vec4 finalColor = _13.uColor;
    outColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _21;

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _59;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
} _10;

uniform sampler2D diffuse;

in vec2 texCoord;
layout(location = 0) out vec4 fragColor;

void main()
{
    bool _17 = _10.drawDepth == 1;
    vec4 finalColor;
    if (_17)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture(diffuse, texCoord).xyz, 255.0);
    }
    fragColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec3 uColor;
} _22;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _13;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec3 uColor;
} _19;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    fragColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(location = 0) in vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uColor;
} _13;

layout(location = 0) out vec4 fragColor;
in vec4 vPos;

void main()
{
    fragColor = vec4(_13.uColor, 1.0);
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _29;

layout(location = 0) in vec3 aPosition;
out vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec4 uColor;
} _12;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = _12.uColor;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _30;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _40;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockVS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
} _36;

out vec2 texCoord;
layout(location = 0) in vec2 position;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.5, 1.0);
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 texOffsetX;
    vec4 texOffsetY;
} _33;

uniform sampler2D texture0;

in vec2 texCoord;
layout(location = 0) out vec4 out_result;

void main()
{
    vec2 tex_offset = vec2(0.001000000047497451305389404296875);
    vec3 result = texture(texture0, texCoord).xyz * 0.0;
    result = vec3(0.0);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.x * tex_offset.x, _33.texOffsetY.x * tex_offset.y)).xyz * 0.125);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.y * tex_offset.x, _33.texOffsetY.y * tex_offset.y)).xyz * 0.375);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.z * tex_offset.x, _33.texOffsetY.z * tex_offset.y)).xyz * 0.375);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.w * tex_offset.x, _33.texOffsetY.w * tex_offset.y)).xyz * 0.125);
    out_result = vec4(result, 1.0);
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 blurAmount;
} _34;

uniform sampler2D screenTex;
uniform sampler2D blurTex;

in vec2 texCoord;
layout(location = 0) out vec4 Out_Color;

void main()
{
    vec4 screen = texture(screenTex, texCoord);
    vec3 blurred = texture(blurTex, texCoord).xyz;
    vec3 mixed = mix(screen.xyz, blurred, vec3(_34.blurAmount.z));
    vec3 glow = (blurred * blurred) * _34.blurAmount.w;
    Out_Color = vec4(mixed + glow, screen.w);
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D Texture;

layout(location = 0) out vec4 Out_Color;
in vec4 Frag_Color;
in vec2 Frag_UV;

void main()
{
    Out_Color = Frag_Color * texture(Texture, Frag_UV);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 ProjMtx;
} _30;

out vec2 Frag_UV;
layout(location = 1) in vec2 UV;
out vec4 Frag_Color;
layout(location = 2) in vec4 Color;
layout(location = 0) in vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30.ProjMtx * vec4(Position, 0.0, 1.0);
}


#version 330

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
} _212;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _378;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec2 vTexcoord0;
in vec2 vTexcoord1;
in vec2 vTexcoord2;
in vec4 vColor;
in vec3 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _162 = nDotSun > 0.0;
    if (_162)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    vec4 tex2 = texture(uTexture2, vTexcoord1);
    vec4 tex3 = texture(uTexture3, vTexcoord2);
    float uAlphaTest = _212.uAlphaTestv.x;
    bool _219 = tex.w < uAlphaTest;
    if (_219)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _212.uPixelShaderv.x;
    bool _246 = uNonOptPixelShader == 0;
    if (_246)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        bool _267 = uNonOptPixelShader == 1;
        if (_267)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            bool _299 = uNonOptPixelShader == 2;
            if (_299)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                bool _330 = uNonOptPixelShader == 3;
                if (_330)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    bool _361 = uNonOptPixelShader == 4;
                    if (_361)
                    {
                    }
                }
            }
        }
    }
    bool _367 = finalColor.w < uAlphaTest;
    if (_367)
    {
        discard;
    }
    vec3 sunDir = _378.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _378.fogData.densityParams;
    arg.heightPlane = _378.fogData.heightPlane;
    arg.color_and_heightRate = _378.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _378.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _378.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _378.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _378.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    vec3 _413 = makeFog(arg, param, param_1, param_2);
    finalColor = vec4(_413.x, _413.y, _413.z, finalColor.w);
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _43;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec2 vTexcoord1;
layout(location = 3) in vec2 aTexcoord1;
out vec2 vTexcoord2;
layout(location = 4) in vec2 aTexcoord2;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    vec4 vertexViewSpace = _43.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _43.scene.uPMatrix * vertexViewSpace;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight;
    vec4 uFogColorAndAlphaTest;
    vec4 uPcColor;
} _409;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCountAndBcHack;
    vec4 interiorExteriorBlend;
} _433;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _472;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _480;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vDiffuseColor;
in vec3 vPosition;
in vec3 vNormal;
layout(location = 0) out vec4 outputColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _42 = !applyLight;
    if (_42)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _59 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_59)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _97 = nDotUp >= 0.0;
        if (_97)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _137 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_137)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _161 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_161)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _334 = nDotSun > 0.0;
    if (_334)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture(uTexture, texCoord);
    vec4 tex2 = texture(uTexture2, texCoord2);
    vec4 tex3 = texture(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    bool _413 = _409.PixelShader_UnFogged_IsAffectedByLight.z == 1;
    vec3 accumLight;
    if (_413)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_433.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _449 = index >= _433.lightCountAndBcHack.x;
            if (_449)
            {
                break;
            }
            lightRecord.color = _433.pc_lights[index].color;
            lightRecord.position = _433.pc_lights[index].position;
            lightRecord.attenuation = _433.pc_lights[index].attenuation;
            vec3 vectorToLight = (_472.scene.uLookAtMat * (_480.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _547 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_547.x, _547.y, _547.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_433.lightCountAndBcHack.y)));
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _409.PixelShader_UnFogged_IsAffectedByLight.x;
    bool _574 = uPixelShader == 0;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _595 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _615 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _643 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _668 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _689 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _709 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _736 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _765 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _791 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _816 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _839 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _863 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _891 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _914 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _941 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * genericParams[0].z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _977 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1003 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1051 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1081 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1109 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1135 = uPixelShader == 21;
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1165 = uPixelShader == 22;
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1192 = uPixelShader == 23;
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1221 = uPixelShader == 24;
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * genericParams[0].x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1253 = uPixelShader == 25;
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * genericParams[0].z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1295 = uPixelShader == 26;
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1340 = uPixelShader == 27;
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1374 = uPixelShader == 28;
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1422 = uPixelShader == 29;
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1446 = uPixelShader == 30;
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1491 = uPixelShader == 31;
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1526 = uPixelShader == 32;
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1568 = uPixelShader == 33;
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1592 = uPixelShader == 34;
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    bool _1598 = uPixelShader == 35;
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    opacity = (((tex * tex2) * tex3) * genericParams[0]).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    bool _1633 = uPixelShader == 36;
    #if (FRAGMENTSHADER == 36)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _409.PixelShader_UnFogged_IsAffectedByLight.z > 0;
    float param_3 = _433.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _472.scene.uLookAtMat;
    param_4.uPMatrix = _472.scene.uPMatrix;
    param_4.uViewUp = _472.scene.uViewUp;
    param_4.uInteriorSunDir = _472.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _472.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _472.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _472.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _472.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _472.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _433.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _433.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular), finalOpacity);
    bool _1715 = finalColor.w < _409.uFogColorAndAlphaTest.w;
    if (_1715)
    {
        discard;
    }
    int uUnFogged = _409.PixelShader_UnFogged_IsAffectedByLight.y;
    bool _1723 = uUnFogged == 0;
    if (_1723)
    {
        vec3 sunDir = mix(_472.scene.uInteriorSunDir, _472.scene.extLight.uExteriorDirectColorDir, vec4(_433.interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _472.fogData.densityParams;
        arg.heightPlane = _472.fogData.heightPlane;
        arg.color_and_heightRate = _472.fogData.color_and_heightRate;
        arg.heightDensity_and_endColor = _472.fogData.heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _472.fogData.sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _472.fogData.heightColor_and_endFogDistance;
        arg.sunPercentage = _472.fogData.sunPercentage;
        vec3 param_7 = finalColor.xyz;
        vec3 param_8 = vPosition;
        vec3 param_9 = sunDir;
        vec3 _1765 = makeFog(arg, param_7, param_8, param_9);
        finalColor = vec4(_1765.x, _1765.y, _1765.z, finalColor.w);
    }
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _133;

layout(std140) uniform meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
} _230;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _240;

layout(location = 0) in vec3 aPosition;
layout(location = 3) in vec4 boneWeights;
layout(location = 2) in vec4 bones;
layout(location = 1) in vec3 aNormal;
out vec2 vTexCoord2;
out vec2 vTexCoord3;
out vec4 vDiffuseColor;
out vec2 vTexCoord;
layout(location = 4) in vec2 aTexCoord;
layout(location = 5) in vec2 aTexCoord2;
out vec3 vNormal;
out vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_240.scene.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _240.scene.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    bool _305 = uVertexShader == 0;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _332 = uVertexShader == 1;
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    bool _347 = uVertexShader == 2;
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _379 = uVertexShader == 3;
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    bool _403 = uVertexShader == 4;
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _427 = uVertexShader == 5;
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    bool _444 = uVertexShader == 6;
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _476 = uVertexShader == 7;
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _507 = uVertexShader == 8;
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _546 = uVertexShader == 9;
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _571 = uVertexShader == 10;
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _594 = uVertexShader == 11;
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _626 = uVertexShader == 12;
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _659 = uVertexShader == 13;
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    bool _677 = uVertexShader == 14;
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _716 = uVertexShader == 15;
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    bool _748 = uVertexShader == 16;
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    bool _780 = uVertexShader == 17;
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _803 = uVertexShader == 18;
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _240.scene.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
} _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

in vec2 v_texcoord;
layout(location = 0) out vec4 outputColor;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    bool _240 = (lumaB < lumaMin) || (lumaB > lumaMax);
    if (_240)
    {
        outputColor = vec4(rgbA.x, rgbA.y, rgbA.z, outputColor.w);
    }
    else
    {
        outputColor = vec4(rgbB.x, rgbB.y, rgbB.z, outputColor.w);
    }
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(location = 0) in vec4 a_position;
out vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 330

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _221;

uniform sampler2D uTexture;

in vec2 vTexcoord0;
in vec4 vColor;
in vec3 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _162 = nDotSun > 0.0;
    if (_162)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    vec4 finalColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
    vec3 sunDir = _221.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _221.fogData.densityParams;
    arg.heightPlane = _221.fogData.heightPlane;
    arg.color_and_heightRate = _221.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _221.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _221.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _221.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _221.fogData.sunPercentage;
    vec3 param = finalColor.xyz;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    vec3 _256 = makeFog(arg, param, param_1, param_2);
    finalColor = vec4(_256.x, _256.y, _256.z, finalColor.w);
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _37;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vec4 vertexViewSpace = _37.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _37.scene.uPMatrix * vertexViewSpace;
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(location = 0) out vec4 outputColor;
in vec4 vColor;

void main()
{
    outputColor = vec4(vColor.xyz, 1.0);
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _50;

layout(std140) uniform meshWideBlockVS
{
    vec4 skyColor[6];
} _82;

layout(location = 0) in vec4 aPosition;
out vec4 vColor;

void main()
{
    vec3 inputPos = aPosition.xyz;
    vec2 _20 = inputPos.xy / vec2(0.6875);
    inputPos = vec3(_20.x, _20.y, inputPos.z);
    bool _30 = inputPos.z > 0.0;
    float _31;
    if (_30)
    {
        _31 = inputPos.z / 0.292800009250640869140625;
    }
    else
    {
        _31 = inputPos.z;
    }
    inputPos.z = _31;
    vec4 cameraPos = _50.scene.uLookAtMat * vec4(inputPos, 1.0);
    vec3 _70 = cameraPos.xyz - _50.scene.uLookAtMat[3].xyz;
    cameraPos = vec4(_70.x, _70.y, _70.z, cameraPos.w);
    cameraPos.z = cameraPos.z;
    vColor = vec4(_82.skyColor[int(aPosition.w)].xyz, 1.0);
    gl_Position = _50.scene.uPMatrix * cameraPos;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    ivec4 waterTypeV;
} _12;

uniform sampler2D uTexture;

layout(location = 0) out vec4 outputColor;
in vec3 vPosition;

void main()
{
    int waterType = _12.waterTypeV.x;
    bool _22 = waterType == 13;
    if (_22)
    {
        outputColor = vec4(0.0, 0.0, 0.300000011920928955078125, 0.5);
    }
    else
    {
        bool _36 = waterType == 14;
        if (_36)
        {
            outputColor = vec4(0.0, 0.0, 0.800000011920928955078125, 0.800000011920928955078125);
        }
        else
        {
            bool _44 = waterType == 19;
            if (_44)
            {
                outputColor = vec4(0.300000011920928955078125, 0.0, 0.0, 0.5);
            }
            else
            {
                bool _51 = waterType == 20;
                if (_51)
                {
                    outputColor = vec4(0.0, 0.5, 0.0, 0.5);
                }
                else
                {
                    outputColor = vec4(0.5);
                }
            }
        }
    }
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _24;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _32;

layout(location = 0) in vec3 aPosition;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 cameraMatrix = _24.uLookAtMat * _32.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    gl_Position = _24.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 UseLitColor_EnableAlpha_PixelShader;
    vec4 FogColor_AlphaTest;
} _383;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _848;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
} _852;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vColor;
in vec4 vColor2;
in vec3 vNormal;
in vec4 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular)
{
    vec3 localDiffuse = accumLight;
    bool _42 = !applyLight;
    if (_42)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _59 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_59)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _97 = nDotUp >= 0.0;
        if (_97)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _137 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_137)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _161 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_161)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 makeFog(PSFog fogData, vec3 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    vec3 endColor = l_heightDensity_and_endColor.yzw;
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 heightColor = mix(l_heightColor_and_endFogDistance.xyz, endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 fogFinal = mix(l_color_and_heightRate.xyz, endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 sunColor = mix(fogFinal, fogData.sunAngle_and_sunColor.yzw, vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _334 = nDotSun > 0.0;
    if (_334)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final, vec3(min(finalFog, endFadeFog)));
    return fogFinal;
}

void main()
{
    vec4 tex = texture(uTexture, vTexCoord);
    vec4 tex2 = texture(uTexture2, vTexCoord2);
    vec4 tex3 = texture(uTexture3, vTexCoord3);
    bool _387 = _383.UseLitColor_EnableAlpha_PixelShader.y == 1;
    if (_387)
    {
        bool _394 = (tex.w - 0.501960813999176025390625) < 0.0;
        if (_394)
        {
            discard;
        }
    }
    int uPixelShader = _383.UseLitColor_EnableAlpha_PixelShader.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 matDiffuse = vec3(0.0);
    vec3 env = vec3(0.0);
    float finalOpacity = 0.0;
    bool _409 = uPixelShader == (-1);
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalOpacity = tex.w;
    #endif
    bool _430 = uPixelShader == 0;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _445 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _458 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _471 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = tex2.xyz * tex.w;
    finalOpacity = vColor.w;
    #endif
    bool _489 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _502 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex.xyz * tex.w) * tex2.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _523 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _552 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz * (vColor.xyz * 2.0);
    env = (colorMix.xyz * colorMix.w) * tex3.xyz;
    finalOpacity = vColor.w;
    #endif
    bool _581 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _605 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = vColor.w;
    #endif
    bool _627 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = vColor.w;
    #endif
    bool _663 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _694 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    bool _714 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    env = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = vColor.w;
    #endif
    bool _748 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _762 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _776 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _789 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _802 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _815 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    bool _828 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = vPosition.w;
    SceneWideParams param_4;
    param_4.uLookAtMat = _848.scene.uLookAtMat;
    param_4.uPMatrix = _848.scene.uPMatrix;
    param_4.uViewUp = _848.scene.uViewUp;
    param_4.uInteriorSunDir = _848.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _848.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _848.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _848.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _848.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _848.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _852.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _852.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = vec3(0.0);
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vColor2.xyz, vec3(0.0)), finalOpacity);
    bool _909 = finalColor.w < _383.FogColor_AlphaTest.w;
    if (_909)
    {
        discard;
    }
    PSFog arg;
    arg.densityParams = _848.fogData.densityParams;
    arg.heightPlane = _848.fogData.heightPlane;
    arg.color_and_heightRate = _848.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _848.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _848.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _848.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _848.fogData.sunPercentage;
    vec3 param_7 = finalColor.xyz;
    vec3 param_8 = vPosition.xyz;
    vec3 param_9 = _848.scene.extLight.uExteriorDirectColorDir.xyz;
    vec3 _945 = makeFog(arg, param_7, param_8, param_9);
    finalColor = vec4(_945.x, _945.y, _945.z, finalColor.w);
    finalColor.w = 1.0;
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _93;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _111;

layout(std140) uniform meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
} _182;

layout(location = 0) in vec3 aPosition;
out vec4 vPosition;
layout(location = 5) in vec4 aColor;
out vec3 vNormal;
layout(location = 1) in vec3 aNormal;
out vec4 vColor;
out vec4 vColor2;
layout(location = 6) in vec4 aColor2;
out vec2 vTexCoord;
layout(location = 2) in vec2 aTexCoord;
out vec2 vTexCoord2;
layout(location = 3) in vec2 aTexCoord2;
out vec2 vTexCoord3;
layout(location = 4) in vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _111.scene.uLookAtMat * worldPoint;
    mat4 viewModelMat = _111.scene.uLookAtMat * _93.uPlacementMat;
    mat4 param = _111.scene.uLookAtMat;
    mat4 param_1 = _93.uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _111.scene.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _182.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vTexCoord2 = posToTexCoord(param_2, param_3);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


